name: Build and Release Microverse

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  PRODUCT_NAME: Microverse
  SCHEME_NAME: Microverse
  CONFIGURATION: Release

permissions:
  contents: write

jobs:
  build-and-release:
    runs-on: macos-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0 # Full history for changelog generation
        
    - name: Set up Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable
        
    - name: Cache Swift Package Manager
      uses: actions/cache@v3
      with:
        path: .build
        key: ${{ runner.os }}-spm-${{ hashFiles('**/Package.resolved') }}
        restore-keys: |
          ${{ runner.os }}-spm-
          
    - name: Determine version bump
      id: version
      run: |
        # Get the latest release tag (not just any tag)
        LATEST_RELEASE=$(gh release list --limit 1 --json tagName --jq '.[0].tagName // "v0.0.0"' || echo "v0.0.0")
        
        # Get all tags sorted by version for fallback
        LAST_TAG=$(git tag -l 'v*' --sort=-version:refname | head -1 || echo "v0.0.0")
        
        # Use the latest release if it exists, otherwise use the latest tag
        if [ "$LATEST_RELEASE" != "v0.0.0" ]; then
          BASE_TAG="$LATEST_RELEASE"
          echo "Using latest release as base: $BASE_TAG"
        else
          BASE_TAG="$LAST_TAG"
          echo "Using latest tag as base: $BASE_TAG"
        fi
        
        echo "Base version for bump: $BASE_TAG"
        
        # Extract version from base tag
        BASE_VERSION="${BASE_TAG#v}"
        IFS='.' read -ra VERSION_PARTS <<< "$BASE_VERSION"
        MAJOR="${VERSION_PARTS[0]:-0}"
        MINOR="${VERSION_PARTS[1]:-0}"
        PATCH="${VERSION_PARTS[2]:-0}"
        
        # Check commit messages since base tag for version bumping
        if [ "$BASE_TAG" != "v0.0.0" ]; then
          COMMITS_SINCE_TAG=$(git log $BASE_TAG..HEAD --oneline 2>/dev/null || echo "")
        else
          COMMITS_SINCE_TAG=$(git log --oneline)
        fi
        
        # Only bump version if there are new commits
        if [ -z "$COMMITS_SINCE_TAG" ]; then
          echo "No new commits since $BASE_TAG - skipping release"
          echo "skip_release=true" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        # Determine version bump type based on conventional commits
        if echo "$COMMITS_SINCE_TAG" | grep -qE "^[a-f0-9]+\s+(BREAKING CHANGE|.*!:)|^[a-f0-9]+\s+\w+!:"; then
          MAJOR=$((MAJOR + 1))
          MINOR=0
          PATCH=0
          VERSION_TYPE="major"
        elif echo "$COMMITS_SINCE_TAG" | grep -qE "^[a-f0-9]+\s+feat(\(.+\))?:"; then
          MINOR=$((MINOR + 1))
          PATCH=0
          VERSION_TYPE="minor"  
        else
          PATCH=$((PATCH + 1))
          VERSION_TYPE="patch"
        fi
        
        NEW_VERSION="$MAJOR.$MINOR.$PATCH"
        NEW_TAG="v$NEW_VERSION"
        
        echo "Version bump: $BASE_TAG -> $NEW_TAG ($VERSION_TYPE)"
        echo "skip_release=false" >> $GITHUB_OUTPUT
        
        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "new_tag=$NEW_TAG" >> $GITHUB_OUTPUT
        echo "commits_since_tag<<EOF" >> $GITHUB_OUTPUT
        echo "$COMMITS_SINCE_TAG" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
    - name: Check if should proceed
      id: check_proceed
      run: |
        # Skip if no new commits
        if [ "${{ steps.version.outputs.skip_release }}" = "true" ]; then
          echo "should_proceed=false" >> $GITHUB_OUTPUT
          echo "Skipping - no new commits"
          exit 0
        fi
        
        # Check if tag already exists
        if git rev-parse "refs/tags/${{ steps.version.outputs.new_tag }}" >/dev/null 2>&1; then
          echo "should_proceed=false" >> $GITHUB_OUTPUT
          echo "Tag ${{ steps.version.outputs.new_tag }} already exists - skipping"
        else
          echo "should_proceed=true" >> $GITHUB_OUTPUT
          echo "Will create new release ${{ steps.version.outputs.new_tag }}"
        fi
        
    - name: Build Sparkle Tools
      if: steps.check_proceed.outputs.should_proceed == 'true'
      run: |
        echo "Building Sparkle tools for signing..."
        
        # First resolve dependencies to get Sparkle checkout
        swift package resolve
        
        # Build the Sparkle tools (generate_appcast is needed for signing releases)
        cd .build/checkouts/Sparkle
        xcodebuild -project Sparkle.xcodeproj -scheme generate_appcast -configuration Release
        
        # Copy the tools to project root for use
        mkdir -p ../../../sparkle-tools
        cp /Users/runner/Library/Developer/Xcode/DerivedData/*/Build/Products/Release/generate_appcast ../../../sparkle-tools/
        
        echo "Sparkle tools ready"
        
    - name: Build Microverse
      if: steps.check_proceed.outputs.should_proceed == 'true'
      run: |
        echo "Building Microverse v${{ steps.version.outputs.new_version }}"
        
        # Build using Swift Package Manager
        swift build -c release --arch arm64 --arch x86_64
        
        # Create app bundle structure
        APP_PATH="$PRODUCT_NAME.app"
        mkdir -p "$APP_PATH/Contents/MacOS"
        mkdir -p "$APP_PATH/Contents/Resources"
        mkdir -p "$APP_PATH/Contents/Frameworks"
        
        # Copy executable
        cp .build/apple/Products/Release/$PRODUCT_NAME "$APP_PATH/Contents/MacOS/"
        
        # Copy Sparkle framework and fix rpath
        if [ -d ".build/arm64-apple-macosx/release/Sparkle.framework" ]; then
          echo "Copying Sparkle framework..."
          cp -R .build/arm64-apple-macosx/release/Sparkle.framework "$APP_PATH/Contents/Frameworks/"
          install_name_tool -id "@rpath/Sparkle.framework/Versions/B/Sparkle" "$APP_PATH/Contents/Frameworks/Sparkle.framework/Versions/B/Sparkle" 2>/dev/null || true
        elif [ -d ".build/x86_64-apple-macosx/release/Sparkle.framework" ]; then
          echo "Copying Sparkle framework (x86_64)..."
          cp -R .build/x86_64-apple-macosx/release/Sparkle.framework "$APP_PATH/Contents/Frameworks/"
          install_name_tool -id "@rpath/Sparkle.framework/Versions/B/Sparkle" "$APP_PATH/Contents/Frameworks/Sparkle.framework/Versions/B/Sparkle" 2>/dev/null || true
        else
          echo "Warning: Sparkle framework not found, checking other locations..."
          SPARKLE_PATH=$(find .build -name "Sparkle.framework" -type d | head -1)
          if [ -n "$SPARKLE_PATH" ]; then
            cp -R "$SPARKLE_PATH" "$APP_PATH/Contents/Frameworks/"
            install_name_tool -id "@rpath/Sparkle.framework/Versions/B/Sparkle" "$APP_PATH/Contents/Frameworks/Sparkle.framework/Versions/B/Sparkle" 2>/dev/null || true
          else
            echo "Error: Could not find Sparkle framework"
          fi
        fi
        
        # Fix executable rpath for framework loading
        install_name_tool -add_rpath "@loader_path/../Frameworks" "$APP_PATH/Contents/MacOS/$PRODUCT_NAME" 2>/dev/null || true
        
        # Create Info.plist with Sparkle auto-update configuration
        cat > "$APP_PATH/Contents/Info.plist" << EOF
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>CFBundleDevelopmentRegion</key>
            <string>en</string>
            <key>CFBundleExecutable</key>
            <string>$PRODUCT_NAME</string>
            <key>CFBundleIdentifier</key>
            <string>com.microverse.app</string>
            <key>CFBundleInfoDictionaryVersion</key>
            <string>6.0</string>
            <key>CFBundleName</key>
            <string>$PRODUCT_NAME</string>
            <key>CFBundlePackageType</key>
            <string>APPL</string>
            <key>CFBundleShortVersionString</key>
            <string>${{ steps.version.outputs.new_version }}</string>
            <key>CFBundleVersion</key>
            <string>${{ steps.version.outputs.new_version }}</string>
            <key>LSMinimumSystemVersion</key>
            <string>11.0</string>
            <key>CFBundleIconFile</key>
            <string>AppIcon</string>
            <key>CFBundleDisplayName</key>
            <string>$PRODUCT_NAME</string>
            <key>NSHumanReadableCopyright</key>
            <string>Copyright Â© 2025 Ashwini Chaudhary. All rights reserved.</string>
            <key>NSPrincipalClass</key>
            <string>NSApplication</string>
            <key>LSUIElement</key>
            <true/>
            <key>NSSupportsAutomaticTermination</key>
            <false/>
            <key>NSSupportsSuddenTermination</key>
            <false/>
            
            <!-- Sparkle Auto-Update Configuration -->
            <key>SUFeedURL</key>
            <string>https://microverse.ashwch.com/appcast.xml</string>
            <key>SUAutomaticallyUpdate</key>
            <false/>
            <key>SUEnableAutomaticChecks</key>
            <false/>
            <key>SUShowReleaseNotes</key>
            <true/>
            <key>SUAllowsAutomaticUpdates</key>
            <false/>
            <!-- CRITICAL: Enable Installer XPC service for sandboxed apps -->
            <key>SUEnableInstallerLauncherService</key>
            <true/>
            <!-- EdDSA public key for signature verification -->
            <key>SUPublicEDKey</key>
            <string>j6LhwdLf+L0uIllLkfIVFxNLHrg9f3lLUs/5uz5PF7w=</string>
        </dict>
        </plist>
        EOF
        
        # Copy app icon if it exists
        if [ -f "Sources/Microverse/Resources/AppIcon.icns" ]; then
          cp "Sources/Microverse/Resources/AppIcon.icns" "$APP_PATH/Contents/Resources/"
        elif [ -f "Resources/AppIcon.icns" ]; then
          cp "Resources/AppIcon.icns" "$APP_PATH/Contents/Resources/"
        elif [ -f "AppIcon.icns" ]; then
          cp "AppIcon.icns" "$APP_PATH/Contents/Resources/"
        fi
        
        # Make executable
        chmod +x "$APP_PATH/Contents/MacOS/$PRODUCT_NAME"
        
        echo "App bundle created successfully"
        ls -la "$APP_PATH/Contents/MacOS/"
        
    - name: Create DMG
      if: steps.check_proceed.outputs.should_proceed == 'true'
      run: |
        DMG_NAME="${PRODUCT_NAME}-v${{ steps.version.outputs.new_version }}.dmg"
        
        # Create a temporary directory for DMG contents
        mkdir -p dmg-contents
        cp -R "$PRODUCT_NAME.app" dmg-contents/
        
        # Create a symbolic link to Applications folder
        ln -s /Applications dmg-contents/Applications
        
        # Create DMG
        hdiutil create -size 100m -format UDZO -srcfolder dmg-contents -volname "$PRODUCT_NAME" "$DMG_NAME"
        
        echo "DMG created: $DMG_NAME"
        echo "dmg_name=$DMG_NAME" >> $GITHUB_ENV
        
    - name: Generate Changelog
      if: steps.check_proceed.outputs.should_proceed == 'true'
      id: changelog
      run: |
        echo "Generating changelog for v${{ steps.version.outputs.new_version }}"
        
        # Create changelog from commit messages
        cat > CHANGELOG.md << EOF
        # Microverse v${{ steps.version.outputs.new_version }}
        
        A unified system monitoring app for macOS with elegant desktop widgets.
        
        ## What's Changed
        
        EOF
        
        # Add commit messages since last tag
        if [ -n "${{ steps.version.outputs.commits_since_tag }}" ]; then
          # Parse commit messages and group by type
          echo "${{ steps.version.outputs.commits_since_tag }}" | while read line; do
            # Extract commit type and message
            if [[ "$line" =~ ^[a-f0-9]+[[:space:]]+(feat|fix|docs|style|refactor|test|chore)(\(.+\))?:[[:space:]](.+)$ ]]; then
              type="${BASH_REMATCH[1]}"
              message="${BASH_REMATCH[3]}"
              
              case "$type" in
                feat) echo "- â¨ **Feature**: $message" >> CHANGELOG.md ;;
                fix) echo "- ð **Fix**: $message" >> CHANGELOG.md ;;
                docs) echo "- ð **Docs**: $message" >> CHANGELOG.md ;;
                *) echo "- $message" >> CHANGELOG.md ;;
              esac
            else
              # If not conventional commit, just add the message
              echo "- ${line#* }" >> CHANGELOG.md
            fi
          done
        else
          cat >> CHANGELOG.md << EOF
        - Initial release with battery, CPU, and memory monitoring
        - 6 desktop widget styles for different workflows  
        - Elegant tabbed interface with system overview
        - Menu bar integration with customizable display
        EOF
        fi
        
        cat >> CHANGELOG.md << EOF
        
        ## Installation
        
        1. Download the DMG file below
        2. Open the DMG and drag Microverse to Applications
        3. Launch from Applications or Spotlight
        
        **Requires macOS 11.0 or later**
        EOF
        
        # Set output for release notes
        echo "changelog_content<<EOF" >> $GITHUB_OUTPUT
        cat CHANGELOG.md >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
    - name: Create Release
      if: steps.check_proceed.outputs.should_proceed == 'true'
      uses: actions/create-release@v1
      id: create_release
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.version.outputs.new_tag }}
        release_name: "Microverse ${{ steps.version.outputs.new_version }}"
        body: ${{ steps.changelog.outputs.changelog_content }}
        draft: false
        prerelease: false
        
    - name: Upload DMG to Release
      if: steps.check_proceed.outputs.should_proceed == 'true'
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: ./${{ env.dmg_name }}
        asset_name: ${{ env.dmg_name }}
        asset_content_type: application/x-apple-diskimage
        
    - name: Upload App Bundle to Release
      if: steps.check_proceed.outputs.should_proceed == 'true'
      run: |
        # Create zip of app bundle for additional download option
        zip -r "${PRODUCT_NAME}-v${{ steps.version.outputs.new_version }}.zip" "$PRODUCT_NAME.app"
        echo "app_zip=${PRODUCT_NAME}-v${{ steps.version.outputs.new_version }}.zip" >> $GITHUB_ENV
        
    - name: Upload App Zip to Release
      if: steps.check_proceed.outputs.should_proceed == 'true'
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: ./${{ env.app_zip }}
        asset_name: ${{ env.app_zip }}
        asset_content_type: application/zip
        
    - name: Generate Signed Appcast
      if: steps.check_proceed.outputs.should_proceed == 'true'
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        echo "Generating signed appcast with Sparkle (CI-friendly approach)..."
        
        # Create releases directory
        mkdir -p releases
        
        # Download the ZIP file to releases directory
        ZIP_URL=$(gh api repos/${{ github.repository }}/releases/tags/${{ steps.version.outputs.new_tag }} \
          --jq '.assets[] | select(.name | endswith(".zip")) | .browser_download_url')
        
        curl -L -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
             -o "releases/${PRODUCT_NAME}-v${{ steps.version.outputs.new_version }}.zip" \
             "$ZIP_URL"
        
        echo "Downloaded ZIP file:"
        ls -la releases/
        
        # Generate appcast.xml with EdDSA signatures using stdin for private key
        # This avoids Keychain GUI prompts that cause hanging in CI
        echo -n "${{ secrets.SPARKLE_PRIVATE_KEY }}" | \
          ./sparkle-tools/generate_appcast releases/ \
            --ed-key-file - \
            --maximum-deltas 0 \
            --download-url-prefix "https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.new_tag }}/" \
            --verbose
        
        # â MINIMAL "BORING BUT WORKS" SOLUTION (like most apps)
        # 1) Get release notes and convert to simple HTML sidecar file
        echo "Creating HTML sidecar file for generate_appcast auto-linking..."
        NOTES_MD=$(gh release view ${{ steps.version.outputs.new_tag }} --json body --jq '.body' || echo "No release notes")
        
        # Create simple HTML with basic formatting
        {
          echo '<!DOCTYPE html>'
          echo '<html><head><meta charset="utf-8"><title>Release Notes</title>'
          echo '<style>body{font-family:-apple-system,sans-serif;margin:20px;line-height:1.6}h1{color:#007AFF}h2{color:#333}ul{padding-left:20px}strong{color:#007AFF}</style>'
          echo '</head><body>'
          echo "$NOTES_MD" | sed 's/^# /<h1>/; s/^## /<h2>/; s/^- /<li>/; s/\*\*\([^*]*\)\*\*/<strong>\1<\/strong>/g'
          echo '</body></html>'
        } > "releases/${PRODUCT_NAME}-v${{ steps.version.outputs.new_version }}.html"
        
        echo "â Created sidecar HTML: releases/${PRODUCT_NAME}-v${{ steps.version.outputs.new_version }}.html"
        echo "File size: $(wc -c < "releases/${PRODUCT_NAME}-v${{ steps.version.outputs.new_version }}.html") bytes"
        
        # 2) Generate appcast - will auto-detect and link the HTML file  
        echo -n "${{ secrets.SPARKLE_PRIVATE_KEY }}" | \
          ./sparkle-tools/generate_appcast releases/ \
            --ed-key-file - \
            --maximum-deltas 0 \
            --download-url-prefix "https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.new_tag }}/" \
            --verbose
        
        # 3) Verify appcast was generated with release notes link
        if [ -f "releases/appcast.xml" ]; then
          echo "â Appcast generated successfully"
          
          if grep -q "sparkle:releaseNotesLink" releases/appcast.xml; then
            echo "â Release notes link automatically added by generate_appcast"
            grep "sparkle:releaseNotesLink" releases/appcast.xml
          else
            echo "â ï¸ No release notes link found - generate_appcast didn't detect HTML file"
          fi
          
          echo "Final appcast size: $(wc -c < releases/appcast.xml) bytes"
          cat releases/appcast.xml
        else
          echo "â Failed to generate appcast"
          ls -la releases/
          exit 1
        fi
        
    - name: Update GitHub Pages Appcast and Release Notes
      if: steps.check_proceed.outputs.should_proceed == 'true'
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        echo "Updating appcast and release notes on GitHub Pages..."
        
        # Clone the gh-pages branch with token authentication
        git clone -b gh-pages https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git gh-pages-repo
        
        # Copy the signed appcast
        cp releases/appcast.xml gh-pages-repo/appcast.xml
        
        # Copy the HTML release notes file to gh-pages
        if [ -f "releases/${PRODUCT_NAME}-v${{ steps.version.outputs.new_version }}.html" ]; then
          cp "releases/${PRODUCT_NAME}-v${{ steps.version.outputs.new_version }}.html" "gh-pages-repo/"
          echo "â Copied HTML release notes to GitHub Pages"
        else
          echo "â ï¸ Warning: HTML release notes file not found"
        fi
        
        # Commit and push the updated files
        cd gh-pages-repo
        git config user.name "GitHub Actions"
        git config user.email "actions@github.com"
        git add appcast.xml "${PRODUCT_NAME}-v${{ steps.version.outputs.new_version }}.html" || true
        git commit -m "Update appcast and release notes for v${{ steps.version.outputs.new_version }}" || true
        git push origin gh-pages
        
        echo "â Appcast and release notes updated on GitHub Pages"
        echo "ð¡ Release notes will be available at: https://microverse.ashwch.com/${PRODUCT_NAME}-v${{ steps.version.outputs.new_version }}.html"
        

    - name: Build Summary
      if: steps.check_proceed.outputs.should_proceed == 'true'
      run: |
        echo "ð Successfully built and released Microverse v${{ steps.version.outputs.new_version }}"
        echo "ð¦ Assets created:"
        echo "  - ${{ env.dmg_name }} (DMG installer)"
        echo "  - ${{ env.app_zip }} (App bundle)"
        echo "ð Release URL: ${{ steps.create_release.outputs.html_url }}"
        echo ""
        echo "ð¡ Update system:"
        echo "  â Signed appcast.xml automatically updated on GitHub Pages"
        echo "  ð EdDSA signature verification enabled"
        echo "  ð¡ Sparkle will detect updates at https://microverse.ashwch.com/appcast.xml"
        echo "â Release is ready for download!"
        
    - name: Skip Release
      if: steps.check_proceed.outputs.should_proceed == 'false'
      run: |
        if [ "${{ steps.version.outputs.skip_release }}" = "true" ]; then
          echo "â­ï¸  Skipping release - no new commits since last release"
        else
          echo "â­ï¸  Skipping release - tag ${{ steps.version.outputs.new_tag }} already exists"
        fi
        echo "â¹ï¸  No new release will be created for this build"