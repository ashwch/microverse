name: Build and Release Microverse

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  PRODUCT_NAME: Microverse
  SCHEME_NAME: Microverse
  CONFIGURATION: Release

permissions:
  contents: write

jobs:
  build-and-release:
    runs-on: macos-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0 # Full history for changelog generation
        
    - name: Set up Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable
        
    - name: Cache Swift Package Manager
      uses: actions/cache@v3
      with:
        path: .build
        key: ${{ runner.os }}-spm-${{ hashFiles('**/Package.resolved') }}
        restore-keys: |
          ${{ runner.os }}-spm-
          
    - name: Determine version bump
      id: version
      run: |
        # Get the latest release tag (not just any tag)
        LATEST_RELEASE=$(gh release list --limit 1 --json tagName --jq '.[0].tagName // "v0.0.0"' || echo "v0.0.0")
        
        # Get all tags sorted by version for fallback
        LAST_TAG=$(git tag -l 'v*' --sort=-version:refname | head -1 || echo "v0.0.0")
        
        # Use the latest release if it exists, otherwise use the latest tag
        if [ "$LATEST_RELEASE" != "v0.0.0" ]; then
          BASE_TAG="$LATEST_RELEASE"
          echo "Using latest release as base: $BASE_TAG"
        else
          BASE_TAG="$LAST_TAG"
          echo "Using latest tag as base: $BASE_TAG"
        fi
        
        echo "Base version for bump: $BASE_TAG"
        
        # Extract version from base tag
        BASE_VERSION="${BASE_TAG#v}"
        IFS='.' read -ra VERSION_PARTS <<< "$BASE_VERSION"
        MAJOR="${VERSION_PARTS[0]:-0}"
        MINOR="${VERSION_PARTS[1]:-0}"
        PATCH="${VERSION_PARTS[2]:-0}"
        
        # Check commit messages since base tag for version bumping
        if [ "$BASE_TAG" != "v0.0.0" ]; then
          COMMITS_SINCE_TAG=$(git log $BASE_TAG..HEAD --oneline 2>/dev/null || echo "")
        else
          COMMITS_SINCE_TAG=$(git log --oneline)
        fi
        
        # Only bump version if there are new commits
        if [ -z "$COMMITS_SINCE_TAG" ]; then
          echo "No new commits since $BASE_TAG - skipping release"
          echo "skip_release=true" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        # Determine version bump type based on conventional commits
        if echo "$COMMITS_SINCE_TAG" | grep -qE "^[a-f0-9]+\s+(BREAKING CHANGE|.*!:)|^[a-f0-9]+\s+\w+!:"; then
          MAJOR=$((MAJOR + 1))
          MINOR=0
          PATCH=0
          VERSION_TYPE="major"
        elif echo "$COMMITS_SINCE_TAG" | grep -qE "^[a-f0-9]+\s+feat(\(.+\))?:"; then
          MINOR=$((MINOR + 1))
          PATCH=0
          VERSION_TYPE="minor"  
        else
          PATCH=$((PATCH + 1))
          VERSION_TYPE="patch"
        fi
        
        NEW_VERSION="$MAJOR.$MINOR.$PATCH"
        NEW_TAG="v$NEW_VERSION"
        
        echo "Version bump: $BASE_TAG -> $NEW_TAG ($VERSION_TYPE)"
        echo "skip_release=false" >> $GITHUB_OUTPUT
        
        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "new_tag=$NEW_TAG" >> $GITHUB_OUTPUT
        echo "commits_since_tag<<EOF" >> $GITHUB_OUTPUT
        echo "$COMMITS_SINCE_TAG" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
    - name: Check if should proceed
      id: check_proceed
      run: |
        # Skip if no new commits
        if [ "${{ steps.version.outputs.skip_release }}" = "true" ]; then
          echo "should_proceed=false" >> $GITHUB_OUTPUT
          echo "Skipping - no new commits"
          exit 0
        fi
        
        # Check if tag already exists
        if git rev-parse "refs/tags/${{ steps.version.outputs.new_tag }}" >/dev/null 2>&1; then
          echo "should_proceed=false" >> $GITHUB_OUTPUT
          echo "Tag ${{ steps.version.outputs.new_tag }} already exists - skipping"
        else
          echo "should_proceed=true" >> $GITHUB_OUTPUT
          echo "Will create new release ${{ steps.version.outputs.new_tag }}"
        fi
        
    - name: Build Microverse
      if: steps.check_proceed.outputs.should_proceed == 'true'
      run: |
        echo "Building Microverse v${{ steps.version.outputs.new_version }}"
        
        # Build using Swift Package Manager
        swift build -c release --arch arm64 --arch x86_64
        
        # Create app bundle structure
        APP_PATH="$PRODUCT_NAME.app"
        mkdir -p "$APP_PATH/Contents/MacOS"
        mkdir -p "$APP_PATH/Contents/Resources"
        mkdir -p "$APP_PATH/Contents/Frameworks"
        
        # Copy executable
        cp .build/apple/Products/Release/$PRODUCT_NAME "$APP_PATH/Contents/MacOS/"
        
        # Copy Sparkle framework and fix rpath
        if [ -d ".build/arm64-apple-macosx/release/Sparkle.framework" ]; then
          echo "Copying Sparkle framework..."
          cp -R .build/arm64-apple-macosx/release/Sparkle.framework "$APP_PATH/Contents/Frameworks/"
          install_name_tool -id "@rpath/Sparkle.framework/Versions/B/Sparkle" "$APP_PATH/Contents/Frameworks/Sparkle.framework/Versions/B/Sparkle" 2>/dev/null || true
        elif [ -d ".build/x86_64-apple-macosx/release/Sparkle.framework" ]; then
          echo "Copying Sparkle framework (x86_64)..."
          cp -R .build/x86_64-apple-macosx/release/Sparkle.framework "$APP_PATH/Contents/Frameworks/"
          install_name_tool -id "@rpath/Sparkle.framework/Versions/B/Sparkle" "$APP_PATH/Contents/Frameworks/Sparkle.framework/Versions/B/Sparkle" 2>/dev/null || true
        else
          echo "Warning: Sparkle framework not found, checking other locations..."
          SPARKLE_PATH=$(find .build -name "Sparkle.framework" -type d | head -1)
          if [ -n "$SPARKLE_PATH" ]; then
            cp -R "$SPARKLE_PATH" "$APP_PATH/Contents/Frameworks/"
            install_name_tool -id "@rpath/Sparkle.framework/Versions/B/Sparkle" "$APP_PATH/Contents/Frameworks/Sparkle.framework/Versions/B/Sparkle" 2>/dev/null || true
          else
            echo "Error: Could not find Sparkle framework"
          fi
        fi
        
        # Fix executable rpath for framework loading
        install_name_tool -add_rpath "@loader_path/../Frameworks" "$APP_PATH/Contents/MacOS/$PRODUCT_NAME" 2>/dev/null || true
        
        # Create Info.plist
        cat > "$APP_PATH/Contents/Info.plist" << EOF
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>CFBundleExecutable</key>
            <string>$PRODUCT_NAME</string>
            <key>CFBundleIdentifier</key>
            <string>com.microverse.app</string>
            <key>CFBundleName</key>
            <string>$PRODUCT_NAME</string>
            <key>CFBundleDisplayName</key>
            <string>$PRODUCT_NAME</string>
            <key>CFBundleVersion</key>
            <string>${{ steps.version.outputs.new_version }}</string>
            <key>CFBundleShortVersionString</key>
            <string>${{ steps.version.outputs.new_version }}</string>
            <key>CFBundlePackageType</key>
            <string>APPL</string>
            <key>CFBundleSignature</key>
            <string>????</string>
            <key>LSMinimumSystemVersion</key>
            <string>11.0</string>
            <key>CFBundleIconFile</key>
            <string>AppIcon</string>
            <key>NSHumanReadableCopyright</key>
            <string>Copyright Â© 2025 Ashwini Chaudhary. All rights reserved.</string>
            <key>NSHighResolutionCapable</key>
            <true/>
            <key>LSUIElement</key>
            <true/>
            <key>NSSupportsAutomaticTermination</key>
            <true/>
            <key>NSSupportsSuddenTermination</key>
            <true/>
            <key>NSPrincipalClass</key>
            <string>NSApplication</string>
        </dict>
        </plist>
        EOF
        
        # Copy app icon if it exists
        if [ -f "Sources/Microverse/Resources/AppIcon.icns" ]; then
          cp "Sources/Microverse/Resources/AppIcon.icns" "$APP_PATH/Contents/Resources/"
        elif [ -f "Resources/AppIcon.icns" ]; then
          cp "Resources/AppIcon.icns" "$APP_PATH/Contents/Resources/"
        elif [ -f "AppIcon.icns" ]; then
          cp "AppIcon.icns" "$APP_PATH/Contents/Resources/"
        fi
        
        # Make executable
        chmod +x "$APP_PATH/Contents/MacOS/$PRODUCT_NAME"
        
        echo "App bundle created successfully"
        ls -la "$APP_PATH/Contents/MacOS/"
        
    - name: Create DMG
      if: steps.check_proceed.outputs.should_proceed == 'true'
      run: |
        DMG_NAME="${PRODUCT_NAME}-v${{ steps.version.outputs.new_version }}.dmg"
        
        # Create a temporary directory for DMG contents
        mkdir -p dmg-contents
        cp -R "$PRODUCT_NAME.app" dmg-contents/
        
        # Create a symbolic link to Applications folder
        ln -s /Applications dmg-contents/Applications
        
        # Create DMG
        hdiutil create -size 100m -format UDZO -srcfolder dmg-contents -volname "$PRODUCT_NAME" "$DMG_NAME"
        
        echo "DMG created: $DMG_NAME"
        echo "dmg_name=$DMG_NAME" >> $GITHUB_ENV
        
    - name: Generate Changelog
      if: steps.check_proceed.outputs.should_proceed == 'true'
      id: changelog
      run: |
        echo "Generating changelog for v${{ steps.version.outputs.new_version }}"
        
        # Create changelog from commit messages
        cat > CHANGELOG.md << EOF
        # Microverse v${{ steps.version.outputs.new_version }}
        
        A unified system monitoring app for macOS with elegant desktop widgets.
        
        ## What's Changed
        
        EOF
        
        # Add commit messages since last tag
        if [ -n "${{ steps.version.outputs.commits_since_tag }}" ]; then
          # Parse commit messages and group by type
          echo "${{ steps.version.outputs.commits_since_tag }}" | while read line; do
            # Extract commit type and message
            if [[ "$line" =~ ^[a-f0-9]+[[:space:]]+(feat|fix|docs|style|refactor|test|chore)(\(.+\))?:[[:space:]](.+)$ ]]; then
              type="${BASH_REMATCH[1]}"
              message="${BASH_REMATCH[3]}"
              
              case "$type" in
                feat) echo "- â¨ **Feature**: $message" >> CHANGELOG.md ;;
                fix) echo "- ð **Fix**: $message" >> CHANGELOG.md ;;
                docs) echo "- ð **Docs**: $message" >> CHANGELOG.md ;;
                *) echo "- $message" >> CHANGELOG.md ;;
              esac
            else
              # If not conventional commit, just add the message
              echo "- ${line#* }" >> CHANGELOG.md
            fi
          done
        else
          cat >> CHANGELOG.md << EOF
        - Initial release with battery, CPU, and memory monitoring
        - 6 desktop widget styles for different workflows  
        - Elegant tabbed interface with system overview
        - Menu bar integration with customizable display
        EOF
        fi
        
        cat >> CHANGELOG.md << EOF
        
        ## Installation
        
        1. Download the DMG file below
        2. Open the DMG and drag Microverse to Applications
        3. Launch from Applications or Spotlight
        
        **Requires macOS 11.0 or later**
        EOF
        
        # Set output for release notes
        echo "changelog_content<<EOF" >> $GITHUB_OUTPUT
        cat CHANGELOG.md >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
    - name: Create Release
      if: steps.check_proceed.outputs.should_proceed == 'true'
      uses: actions/create-release@v1
      id: create_release
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.version.outputs.new_tag }}
        release_name: "Microverse ${{ steps.version.outputs.new_version }}"
        body: ${{ steps.changelog.outputs.changelog_content }}
        draft: false
        prerelease: false
        
    - name: Upload DMG to Release
      if: steps.check_proceed.outputs.should_proceed == 'true'
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: ./${{ env.dmg_name }}
        asset_name: ${{ env.dmg_name }}
        asset_content_type: application/x-apple-diskimage
        
    - name: Upload App Bundle to Release
      if: steps.check_proceed.outputs.should_proceed == 'true'
      run: |
        # Create zip of app bundle for additional download option
        zip -r "${PRODUCT_NAME}-v${{ steps.version.outputs.new_version }}.zip" "$PRODUCT_NAME.app"
        echo "app_zip=${PRODUCT_NAME}-v${{ steps.version.outputs.new_version }}.zip" >> $GITHUB_ENV
        
    - name: Upload App Zip to Release
      if: steps.check_proceed.outputs.should_proceed == 'true'
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: ./${{ env.app_zip }}
        asset_name: ${{ env.app_zip }}
        asset_content_type: application/zip
        
    - name: Update Appcast
      if: steps.check_proceed.outputs.should_proceed == 'true'  
      run: |
        echo "ð¡ Updating Sparkle appcast with new release..."
        
        # Download Sparkle tools for appcast generation
        curl -L -o sparkle-tools.tar.xz "https://github.com/sparkle-project/Sparkle/releases/download/2.7.1/Sparkle-for-Swift-Package-Manager.tar.xz"
        tar -xf sparkle-tools.tar.xz
        
        # Create releases directory for generate_appcast tool
        mkdir -p releases
        
        # Download the release assets we just created
        DMG_NAME="Microverse-v${{ steps.version.outputs.new_version }}.dmg"
        curl -L -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
             -o "releases/$DMG_NAME" \
             "https://github.com/${{ github.repository }}/releases/download/v${{ steps.version.outputs.new_version }}/$DMG_NAME"
        
        # Create release notes HTML file
        cat > "releases/Microverse-v${{ steps.version.outputs.new_version }}.html" << 'EOF'
        <h2>What's New in ${{ steps.version.outputs.new_version }}</h2>
        <ul>
            <li>â¨ <strong>Feature:</strong> Comprehensive auto-update system with Sparkle integration</li>
            <li>âï¸ <strong>Enhancement:</strong> Redesigned Settings interface with elegant design system</li>
            <li>ð <strong>Feature:</strong> Automatic 24-hour background update checking</li>
            <li>ð¨ <strong>Enhancement:</strong> Enhanced UI components following unified design system</li>
            <li>ð§ <strong>Improvement:</strong> Better framework integration and performance</li>
        </ul>
        
        <h3>System Requirements</h3>
        <p>macOS 11.0 or later</p>
        EOF
        
        # Clone gh-pages to get existing releases 
        git config --global user.name "github-actions[bot]"
        git config --global user.email "github-actions[bot]@users.noreply.github.com"
        
        git clone --depth 1 --branch gh-pages "https://${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git" gh-pages-repo
        
        # Copy existing releases if they exist (for delta updates and history)
        if [ -d gh-pages-repo/releases ]; then
          cp -r gh-pages-repo/releases/* releases/ 2>/dev/null || true
        fi
        
        # Generate appcast using official Sparkle tool
        ./bin/generate_appcast \
          --download-url-prefix "https://github.com/${{ github.repository }}/releases/download/" \
          --link "https://github.com/${{ github.repository }}" \
          --full-release-notes-url "https://github.com/${{ github.repository }}/releases/tag/v${{ steps.version.outputs.new_version }}" \
          releases/
        
        # Move generated appcast and releases to gh-pages
        cd gh-pages-repo
        mv ../appcast.xml .
        mkdir -p releases
        cp -r ../releases/* releases/
        
        # Commit and push changes
        git add appcast.xml releases/
        if git diff --staged --quiet; then
          echo "No changes to appcast"
        else
          git commit -m "update appcast.xml and releases for v${{ steps.version.outputs.new_version }}"
          git push origin gh-pages
          echo "â Appcast updated and published to GitHub Pages"
        fi
        
        cd ..
        rm -rf gh-pages-repo releases sparkle-tools.tar.xz bin/

    - name: Build Summary
      if: steps.check_proceed.outputs.should_proceed == 'true'
      run: |
        echo "ð Successfully built and released Microverse v${{ steps.version.outputs.new_version }}"
        echo "ð¦ Assets created:"
        echo "  - ${{ env.dmg_name }} (DMG installer)"
        echo "  - ${{ env.app_zip }} (App bundle)"
        echo "ð Release URL: ${{ steps.create_release.outputs.html_url }}"
        echo "ð¡ Appcast URL: https://microverse.ashwch.com/appcast.xml"
        echo "â Release is now available for download and auto-update!"
        
    - name: Skip Release
      if: steps.check_proceed.outputs.should_proceed == 'false'
      run: |
        if [ "${{ steps.version.outputs.skip_release }}" = "true" ]; then
          echo "â­ï¸  Skipping release - no new commits since last release"
        else
          echo "â­ï¸  Skipping release - tag ${{ steps.version.outputs.new_tag }} already exists"
        fi
        echo "â¹ï¸  No new release will be created for this build"